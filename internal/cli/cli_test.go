package cli_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/pithecene-io/bonsai/internal/cli"
)

// runApp runs the CLI with the given args and captures stdout.
// Commands write to os.Stdout via fmt.Println, not app.Writer,
// so we redirect os.Stdout with os.Pipe().
func runApp(t *testing.T, args ...string) (stdout string, err error) {
	t.Helper()

	origStdout := os.Stdout
	r, w, pipeErr := os.Pipe()
	if pipeErr != nil {
		t.Fatalf("os.Pipe: %v", pipeErr)
	}
	os.Stdout = w

	app := cli.NewApp()
	runErr := app.Run(append([]string{"bonsai"}, args...))

	_ = w.Close()
	os.Stdout = origStdout

	var buf [1 << 16]byte
	n, _ := r.Read(buf[:])
	_ = r.Close()

	return string(buf[:n]), runErr
}

// initGitRepo creates a minimal git repo in dir so hooks commands work.
func initGitRepo(t *testing.T, dir string) {
	t.Helper()
	hooksDir := filepath.Join(dir, ".git", "hooks")
	if err := os.MkdirAll(hooksDir, 0o755); err != nil {
		t.Fatalf("mkdir .git/hooks: %v", err)
	}
}

// --- hooks install/remove ---

func TestHooksInstall_CreatesPrePushHook(t *testing.T) {
	dir := t.TempDir()
	initGitRepo(t, dir)
	t.Chdir(dir)

	_, err := runApp(t, "hooks", "install")
	if err != nil {
		t.Fatalf("hooks install: %v", err)
	}

	hookFile := filepath.Join(dir, ".git", "hooks", "pre-push")
	info, err := os.Stat(hookFile)
	if err != nil {
		t.Fatalf("hook not created: %v", err)
	}

	// Check marker
	data, _ := os.ReadFile(hookFile)
	if !strings.Contains(string(data), "Auto-generated by bonsai hooks install") {
		t.Error("hook missing bonsai marker")
	}

	// Check executable permission
	if info.Mode()&0o111 == 0 {
		t.Error("hook is not executable")
	}
}

func TestHooksInstall_ExistingHook_NoOverwrite(t *testing.T) {
	dir := t.TempDir()
	initGitRepo(t, dir)
	t.Chdir(dir)

	hookFile := filepath.Join(dir, ".git", "hooks", "pre-push")
	original := "#!/bin/bash\necho existing\n"
	if err := os.WriteFile(hookFile, []byte(original), 0o755); err != nil {
		t.Fatalf("write hook: %v", err)
	}

	// Redirect stdin to EOF → confirmPrompt returns defaultYes=false → abort
	origStdin := os.Stdin
	devNull, _ := os.Open(os.DevNull)
	os.Stdin = devNull
	defer func() { os.Stdin = origStdin; _ = devNull.Close() }()

	_, err := runApp(t, "hooks", "install")
	if err != nil {
		t.Fatalf("hooks install: %v", err)
	}

	// Hook should be unchanged
	data, _ := os.ReadFile(hookFile)
	if string(data) != original {
		t.Error("hook was overwritten despite no confirmation")
	}
}

func TestHooksRemove_RemovesBonsaiHook(t *testing.T) {
	dir := t.TempDir()
	initGitRepo(t, dir)
	t.Chdir(dir)

	// Install first
	_, err := runApp(t, "hooks", "install")
	if err != nil {
		t.Fatalf("hooks install: %v", err)
	}

	// Remove
	_, err = runApp(t, "hooks", "remove")
	if err != nil {
		t.Fatalf("hooks remove: %v", err)
	}

	hookFile := filepath.Join(dir, ".git", "hooks", "pre-push")
	if _, err := os.Stat(hookFile); !os.IsNotExist(err) {
		t.Error("hook still exists after remove")
	}
}

func TestHooksRemove_RefusesNonBonsaiHook(t *testing.T) {
	dir := t.TempDir()
	initGitRepo(t, dir)
	t.Chdir(dir)

	hookFile := filepath.Join(dir, ".git", "hooks", "pre-push")
	if err := os.WriteFile(hookFile, []byte("#!/bin/bash\necho custom\n"), 0o755); err != nil {
		t.Fatalf("write hook: %v", err)
	}

	_, err := runApp(t, "hooks", "remove")
	if err == nil {
		t.Fatal("expected error refusing to remove non-bonsai hook")
	}
	if !strings.Contains(err.Error(), "not installed by bonsai") {
		t.Errorf("unexpected error: %v", err)
	}
}

func TestHooksRemove_NoHookExists(t *testing.T) {
	dir := t.TempDir()
	initGitRepo(t, dir)
	t.Chdir(dir)

	_, err := runApp(t, "hooks", "remove")
	if err != nil {
		t.Fatalf("hooks remove should not error: %v", err)
	}
}

// --- list ---

func TestList_ShowsSkills(t *testing.T) {
	dir := t.TempDir()
	t.Chdir(dir)

	out, err := runApp(t, "list", "--skills")
	if err != nil {
		t.Fatalf("list --skills: %v", err)
	}

	if !strings.Contains(out, "Skills:") {
		t.Error("missing Skills: header")
	}
	if !strings.Contains(out, "repo-convention-enforcer") {
		t.Error("missing repo-convention-enforcer skill")
	}
}

func TestList_ShowsBundles(t *testing.T) {
	dir := t.TempDir()
	t.Chdir(dir)

	out, err := runApp(t, "list", "--bundles")
	if err != nil {
		t.Fatalf("list --bundles: %v", err)
	}

	if !strings.Contains(out, "Bundles:") {
		t.Error("missing Bundles: header")
	}
	if !strings.Contains(out, "default") {
		t.Error("missing default bundle")
	}
}

func TestList_ShowsAll(t *testing.T) {
	dir := t.TempDir()
	t.Chdir(dir)

	out, err := runApp(t, "list")
	if err != nil {
		t.Fatalf("list: %v", err)
	}

	for _, section := range []string{"Skills:", "Bundles:", "Roles:"} {
		if !strings.Contains(out, section) {
			t.Errorf("missing section %q", section)
		}
	}
}

// --- version ---

func TestVersion_PrintsVersion(t *testing.T) {
	out, err := runApp(t, "version")
	if err != nil {
		t.Fatalf("version: %v", err)
	}

	if !strings.Contains(out, cli.Version) {
		t.Errorf("output %q does not contain version %q", out, cli.Version)
	}
}

// --- completion ---

func TestCompletion_Bash(t *testing.T) {
	out, err := runApp(t, "completion", "bash")
	if err != nil {
		t.Fatalf("completion bash: %v", err)
	}
	if !strings.Contains(out, "_bonsai_completions") {
		t.Error("missing bash completion function")
	}
}

func TestCompletion_Zsh(t *testing.T) {
	out, err := runApp(t, "completion", "zsh")
	if err != nil {
		t.Fatalf("completion zsh: %v", err)
	}
	if !strings.Contains(out, "compdef _bonsai bonsai") {
		t.Error("missing zsh compdef")
	}
}

func TestCompletion_Fish(t *testing.T) {
	out, err := runApp(t, "completion", "fish")
	if err != nil {
		t.Fatalf("completion fish: %v", err)
	}
	if !strings.Contains(out, "complete -c bonsai") {
		t.Error("missing fish completion directive")
	}
}

// --- check error paths ---

func TestCheck_MutualExclusion(t *testing.T) {
	_, err := runApp(t, "check", "--mode", "NORMAL", "--bundle", "default")
	if err == nil {
		t.Fatal("expected error for mutually exclusive --mode and --bundle")
	}
	if !strings.Contains(err.Error(), "mutually exclusive") {
		t.Errorf("unexpected error: %v", err)
	}
}

func TestCheck_InvalidMode(t *testing.T) {
	_, err := runApp(t, "check", "--mode", "INVALID")
	if err == nil {
		t.Fatal("expected error for invalid mode")
	}
	if !strings.Contains(err.Error(), "invalid mode") {
		t.Errorf("unexpected error: %v", err)
	}
}

// --- migrate error paths ---

func TestMigrate_NonexistentPath(t *testing.T) {
	_, err := runApp(t, "migrate", "/nonexistent/path/does/not/exist")
	if err == nil {
		t.Fatal("expected error for nonexistent path")
	}
	if !strings.Contains(err.Error(), "directory not found") {
		t.Errorf("unexpected error: %v", err)
	}
}

func TestMigrate_FileNotDirectory(t *testing.T) {
	f := filepath.Join(t.TempDir(), "notadir.txt")
	if err := os.WriteFile(f, []byte("hello"), 0o644); err != nil {
		t.Fatal(err)
	}

	_, err := runApp(t, "migrate", f)
	if err == nil {
		t.Fatal("expected error for file instead of directory")
	}
	if !strings.Contains(err.Error(), "not a directory") {
		t.Errorf("unexpected error: %v", err)
	}
}
