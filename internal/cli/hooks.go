package cli

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/pithecene-io/bonsai/internal/gitutil"
	"github.com/urfave/cli/v2"
)

func hooksCommand() *cli.Command {
	return &cli.Command{
		Name:  "hooks",
		Usage: "Manage git hooks for governance checks",
		Subcommands: []*cli.Command{
			{
				Name:   "install",
				Usage:  "Install pre-push governance hook",
				Action: runHooksInstall,
			},
			{
				Name:   "remove",
				Usage:  "Remove governance pre-push hook",
				Action: runHooksRemove,
			},
		},
	}
}

const hookMarker = "# Auto-generated by bonsai hooks install"

const hookContent = `#!/usr/bin/env bash
# Auto-generated by bonsai hooks install
# Runs bonsai check with default bundle before push

if command -v bonsai >/dev/null 2>&1; then
  echo "▶ Running bonsai check --bundle default"
  bonsai check --bundle default || {
    echo "✖ bonsai check failed. Push blocked." >&2
    exit 1
  }
elif command -v ai-check >/dev/null 2>&1; then
  echo "▶ Running ai-check --bundle default"
  ai-check --bundle default || {
    echo "✖ ai-check failed. Push blocked." >&2
    exit 1
  }
else
  echo "⚠ bonsai/ai-check not found in PATH; skipping pre-push check" >&2
fi
`

func runHooksInstall(c *cli.Context) error {
	// Detect repo root
	repoRoot := "."
	if gitutil.IsInsideWorkTree(".") {
		if r, err := gitutil.ShowToplevel("."); err == nil {
			repoRoot = r
		}
	}

	hooksDir := filepath.Join(repoRoot, ".git", "hooks")
	if !isDirectory(hooksDir) {
		return fmt.Errorf("not inside a git repository (no .git/hooks)")
	}

	hookFile := filepath.Join(hooksDir, "pre-push")

	// Check if hook already exists
	if fileExists(hookFile) {
		data, _ := os.ReadFile(hookFile)
		content := string(data)

		fmt.Fprintf(os.Stderr, "warning: %s already exists\n", hookFile)

		// Show first 5 lines
		lines := strings.Split(content, "\n")
		fmt.Fprintln(os.Stderr, "Existing content:")
		for i, line := range lines {
			if i >= 5 {
				break
			}
			fmt.Fprintf(os.Stderr, "  %s\n", line)
		}

		if !confirmPrompt("Overwrite? [y/N] ", false) {
			fmt.Println("Aborted.")
			return nil
		}
	}

	if err := os.WriteFile(hookFile, []byte(hookContent), 0o755); err != nil {
		return fmt.Errorf("write hook: %w", err)
	}

	fmt.Printf("Installed pre-push hook: %s\n", hookFile)
	return nil
}

func runHooksRemove(c *cli.Context) error {
	// Detect repo root
	repoRoot := "."
	if gitutil.IsInsideWorkTree(".") {
		if r, err := gitutil.ShowToplevel("."); err == nil {
			repoRoot = r
		}
	}

	hookFile := filepath.Join(repoRoot, ".git", "hooks", "pre-push")

	if !fileExists(hookFile) {
		fmt.Println("No pre-push hook found.")
		return nil
	}

	// Only remove if it's our hook
	data, err := os.ReadFile(hookFile)
	if err != nil {
		return fmt.Errorf("read hook: %w", err)
	}

	if !strings.Contains(string(data), hookMarker) {
		return fmt.Errorf("pre-push hook exists but was not installed by bonsai — refusing to remove")
	}

	if err := os.Remove(hookFile); err != nil {
		return fmt.Errorf("remove hook: %w", err)
	}

	fmt.Printf("Removed pre-push hook: %s\n", hookFile)
	return nil
}
